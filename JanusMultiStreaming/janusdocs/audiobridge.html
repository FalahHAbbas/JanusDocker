<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>AudioBridge plugin documentation</title>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cerulean/bootstrap.min.css" rel="stylesheet">
<link href="css/demo.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<a href="https://github.com/meetecho/janus-gateway"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 1001;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
<nav class="navbar navbar-default navbar-static-top">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href=".">Janus</a>
		<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
	</div>
	<div class="navbar-collapse collapse">
		<ul class="nav navbar-nav">
			<li><a href="https://janus.conf.meetecho.com/">Home</a></li>
			<li><a href="https://janus.conf.meetecho.com/demos.html">Demos</a></li>
			<li class="active"><a href="index.html">Documentation</a></li>
			<li><a href="https://janus.conf.meetecho.com/citeus.html">Papers</a></li>
			<li><a href="https://janus.conf.meetecho.com/support.html">Need help?</a></li>
			<li><a class="januscon" target="_blank" href="https://januscon.it">JanusCon!</a></li>
		</ul>
		<div class="navbar-header navbar-right">
			<ul class="nav navbar-nav">
				<li><a target="_blank" href="http://www.meetecho.com" class="navbar-link meetecho-logo"><img src="meetecho-logo.png"/></a></li>
			</ul>
		</div>
	</div>
</div>
</nav>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">AudioBridge plugin documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a plugin implementing an audio conference bridge for Janus, specifically mixing Opus streams. This means that it replies by providing in the SDP only support for Opus, and disabling video. Opus encoding and decoding is implemented using libopus (<a href="http://opus.codec.org">http://opus.codec.org</a>). The plugin provides an API to allow peers to join and leave conference rooms. Peers can then mute/unmute themselves by sending specific messages to the plugin: any way a peer mutes/unmutes, an event is triggered to the other participants, so that it can be rendered in the UI accordingly.</p>
<p>Rooms to make available are listed in the plugin configuration file. A pre-filled configuration file is provided in <code>conf/janus.plugin.audiobridge.jcfg</code> and includes a demo room for testing.</p>
<p>To add more rooms or modify the existing one, you can use the following syntax:</p>
<pre class="fragment">room-&lt;unique room ID&gt;: {
        description = This is my awesome room
        is_private = true|false (private rooms don't appear when you do a 'list' request)
        secret = &lt;optional password needed for manipulating (e.g. destroying) the room&gt;
        pin = &lt;optional password needed for joining the room&gt;
        sampling_rate = &lt;sampling rate&gt; (e.g., 16000 for wideband mixing)
        audiolevel_ext = true|false (whether the ssrc-audio-level RTP extension must be
                negotiated/used or not for new joins, default=true)
        audiolevel_event = true|false (whether to emit event to other users or not, default=false)
        audio_active_packets = 100 (number of packets with audio level, default=100, 2 seconds)
        audio_level_average = 25 (average value of audio level, 127=muted, 0='too loud', default=25)
        default_prebuffering = number of packets to buffer before decoding each participant (default=DEFAULT_PREBUFFERING)
        record = true|false (whether this room should be recorded, default=false)
        record_file =   /path/to/recording.wav (where to save the recording)

                [The following lines are only needed if you want the mixed audio
                to be automatically forwarded via plain RTP to an external component
                (e.g., an ffmpeg script, or a gstreamer pipeline) for processing.
                By default plain RTP is used, SRTP must be configured if needed]
        rtp_forward_id = numeric RTP forwarder ID for referencing it via API (optional: random ID used if missing)
        rtp_forward_host = host address to forward RTP packets of mixed audio to
        rtp_forward_host_family = ipv4|ipv6; by default, first family returned by DNS request
        rtp_forward_port = port to forward RTP packets of mixed audio to
        rtp_forward_ssrc = SSRC to use to use when streaming (optional: stream_id used if missing)
        rtp_forward_codec = opus (default), pcma (A-Law) or pcmu (mu-Law)
        rtp_forward_ptype = payload type to use when streaming (optional: only read for Opus, 100 used if missing)
        rtp_forward_srtp_suite = length of authentication tag, if SRTP is needed (32 or 80)
        rtp_forward_srtp_crypto = key to use as crypto, if SRTP is needed (base64 encoded key as in SDES)
        rtp_forward_always_on = true|false, whether silence should be forwarded when the room is empty (optional: false used if missing)
}
</pre><h1><a class="anchor" id="bridgeapi"></a>
Audio Bridge API</h1>
<p>The Audio Bridge API supports several requests, some of which are synchronous and some asynchronous. There are some situations, though, (invalid JSON, invalid request) which will always result in a synchronous error response even for asynchronous requests.</p>
<p><code>create</code> , <code>edit</code> , <code>destroy</code> , <code>exists</code>, <code>allowed</code>, <code>kick</code>, <code>list</code>, <code>mute</code> , <code>unmute</code> , <code>mute_room</code> , <code>unmute_room</code> , <code>listparticipants</code> , <code>resetdecoder</code> , <code>rtp_forward</code>, <code>stop_rtp_forward</code> , <code>list_forwarders</code> , <code>play_file</code> , <code>is_playing</code> and <code>stop_file</code> are synchronous requests, which means you'll get a response directly within the context of the transaction. <code>create</code> allows you to create a new audio conference bridge dynamically, as an alternative to using the configuration file; <code>edit</code> allows you to dynamically edit some room properties (e.g., the PIN); <code>destroy</code> removes an audio conference bridge and destroys it, kicking all the users out as part of the process; <code>exists</code> allows you to check whether a specific audio conference exists; <code>allowed</code> allows you to edit who's allowed to join a room via ad-hoc tokens; <code>list</code> lists all the available rooms, while <code>listparticipants</code> lists all the participants of a specific room and their details; <code>resetdecoder</code> marks the Opus decoder for the participant as invalid, and forces it to be recreated (which might be needed if the audio for generated by the participant becomes garbled); <code>rtp_forward</code> allows you to forward the mix of an AudioBridge room via RTP to a separate component (e.g., for broadcasting it to a wider audience, or for processing/recording), whereas <code>stop_rtp_forward</code> can remove an existing forwarder; a list of configured forwarders for a room can be retrieved using the <code>list_forwarders</code> request; finally, <code>play_file</code> allows you to reproduce an audio .opus file in a mix (e.g., to play an announcement or some background music), <code>is_playing</code> checks if a specific file is still playing, while <code>stop_file</code> will stop such a playback instead.</p>
<p>The <code>join</code> , <code>configure</code> , <code>changeroom</code> and <code>leave</code> requests instead are all asynchronous, which means you'll get a notification about their success or failure in an event. <code>join</code> allows you to join a specific audio conference bridge; <code>configure</code> can be used to modify some of the participation settings (e.g., mute/unmute); <code>changeroom</code> can be used to leave the current room and move to a different one without having to tear down the PeerConnection and recreate it again (useful for sidebars and "waiting rooms"); finally, <code>leave</code> allows you to leave an audio conference bridge for good.</p>
<p>The AudioBridge plugin also allows you to forward the mix to an external listener, e.g., a gstreamer/ffmpeg pipeline waiting to process the mixer audio stream. You can add new RTP forwarders with the <code>rtp_forward</code> request; a <code>stop_rtp_forward</code> request removes an existing RTP forwarder; <code>listforwarders</code> lists all the current RTP forwarders on a specific AudioBridge room instance. As an alternative, you can configure a single static RTP forwarder in the plugin configuration file.</p>
<p><code>create</code> can be used to create a new audio room, and has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "create",
        "room" : &lt;unique numeric ID, optional, chosen by plugin if missing&gt;,
        "permanent" : &lt;true|false, whether the room should be saved in the config file, default=false&gt;,
        "description" : "&lt;pretty name of the room, optional&gt;",
        "secret" : "&lt;password required to edit/destroy the room, optional&gt;",
        "pin" : "&lt;password required to join the room, optional&gt;",
        "is_private" : &lt;true|false, whether the room should appear in a list request&gt;,
        "allowed" : [ array of string tokens users can use to join this room, optional],
        "sampling_rate" : &lt;sampling rate of the room, optional, 16000 by default&gt;,
        "audiolevel_ext" : &lt;true|false, whether the ssrc-audio-level RTP extension must be negotiated for new joins, default=true&gt;,
        "audiolevel_event" : &lt;true|false (whether to emit event to other users or not)&gt;,
        "audio_active_packets" : &lt;number of packets with audio level (default=100, 2 seconds)&gt;,
        "audio_level_average" : &lt;average value of audio level (127=muted, 0='too loud', default=25)&gt;,
        "default_prebuffering" : &lt;number of packets to buffer before decoding each participant (default=DEFAULT_PREBUFFERING)&gt;,
        "record" : &lt;true|false, whether to record the room or not, default=false&gt;,
        "record_file" : "&lt;/path/to/the/recording.wav, optional&gt;",
}
</pre><p>A successful creation procedure will result in a <code>created</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "created",
        "room" : &lt;unique numeric ID&gt;,
        "permanent" : &lt;true if saved to config file, false if not&gt;
}
</pre><p>If you requested a permanent room but a <code>false</code> value is returned instead, good chances are that there are permission problems.</p>
<p>An error instead (and the same applies to all other requests, so this won't be repeated) would provide both an error code and a more verbose description of the cause of the issue:</p>
<pre class="fragment">{
        "audiobridge" : "event",
        "error_code" : &lt;numeric ID, check Macros below&gt;,
        "error" : "&lt;error description as a string&gt;"
}
</pre><p>Notice that, in general, all users can create rooms. If you want to limit this functionality, you can configure an admin <code>admin_key</code> in the plugin settings. When configured, only "create" requests that include the correct <code>admin_key</code> value in an "admin_key" property will succeed, and will be rejected otherwise. Notice that you can optionally extend this functionality to RTP forwarding as well, in order to only allow trusted clients to use that feature.</p>
<p>Once a room has been created, you can still edit some (but not all) of its properties using the <code>edit</code> request. This allows you to modify the room description, secret, pin and whether it's private or not: you won't be able to modify other more static properties, like the room ID, the sampling rate, the extensions-related stuff and so on. If you're interested in changing the ACL, instead, check the <code>allowed</code> message. An <code>edit</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "edit",
        "room" : &lt;unique numeric ID of the room to edit&gt;,
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "new_description" : "&lt;new pretty name of the room, optional&gt;",
        "new_secret" : "&lt;new password required to edit/destroy the room, optional&gt;",
        "new_pin" : "&lt;new password required to join the room, optional&gt;",
        "new_is_private" : &lt;true|false, whether the room should appear in a list request&gt;,
        "permanent" : &lt;true|false, whether the room should be also removed from the config file, default=false&gt;
}
</pre><p>A successful edit procedure will result in an <code>edited</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "edited",
        "room" : &lt;unique numeric ID&gt;
}
</pre><p>On the other hand, <code>destroy</code> can be used to destroy an existing audio room, whether created dynamically or statically, and has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "destroy",
        "room" : &lt;unique numeric ID of the room to destroy&gt;,
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "permanent" : &lt;true|false, whether the room should be also removed from the config file, default=false&gt;
}
</pre><p>A successful destruction procedure will result in a <code>destroyed</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "destroyed",
        "room" : &lt;unique numeric ID&gt;
}
</pre><p>This will also result in a <code>destroyed</code> event being sent to all the participants in the audio room, which will look like this:</p>
<pre class="fragment">{
        "audiobridge" : "destroyed",
        "room" : &lt;unique numeric ID of the destroyed room&gt;
}
</pre><p>You can check whether a room exists using the <code>exists</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "exists",
        "room" : &lt;unique numeric ID of the room to check&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID&gt;,
        "exists" : &lt;true|false&gt;
}
</pre><p>You can configure whether to check tokens or add/remove people who can join a room using the <code>allowed</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "allowed",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "action" : "enable|disable|add|remove",
        "room" : &lt;unique numeric ID of the room to update&gt;,
        "allowed" : [
                // Array of strings (tokens users might pass in "join", only for add|remove)
        ]
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID&gt;,
        "allowed" : [
                // Updated, complete, list of allowed tokens (only for enable|add|remove)
        ]
}
</pre><p>If you're the administrator of a room (that is, you created it and have access to the secret) you can kick participants using the <code>kick</code> request. Notice that this only kicks the user out of the room, but does not prevent them from re-joining: to ban them, you need to first remove them from the list of authorized users (see <code>allowed</code> request) and then <code>kick</code> them. The <code>kick</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "kick",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;,
        "id" : &lt;unique numeric ID of the participant to kick&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
}
</pre><p>To get a list of the available rooms (excluded those configured or created as private rooms) you can make use of the <code>list</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "list"
}
</pre><p>A successful request will produce a list of rooms in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "rooms" : [             // Array of room objects
                {       // Room #1
                        "room" : &lt;unique numeric ID&gt;,
                        "description" : "&lt;Name of the room&gt;",
                        "pin_required" : &lt;true|false, whether a PIN is required to join this room&gt;,
                        "sampling_rate" : &lt;sampling rate of the mixer&gt;,
                        "record" : &lt;true|false, whether the room is being recorded&gt;,
                        "num_participants" : &lt;count of the participants&gt;
                },
                // Other rooms
        ]
}
</pre><p>To get a list of the participants in a specific room, instead, you can make use of the <code>listparticipants</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "listparticipants",
        "room" : &lt;unique numeric ID of the room&gt;
}
</pre><p>A successful request will produce a list of participants in a <code>participants</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "participants",
        "room" : &lt;unique numeric ID of the room&gt;,
        "participants" : [              // Array of participant objects
                {       // Participant #1
                        "id" : &lt;unique numeric ID of the participant&gt;,
                        "display" : "&lt;display name of the participant, if any; optional&gt;",
                        "setup" : &lt;true|false, whether user successfully negotiate a WebRTC PeerConnection or not&gt;,
                        "muted" : &lt;true|false, whether user is muted or not&gt;,
                        "talking" : &lt;true|false, whether user is talking or not (only if audio levels are used)&gt;,
                },
                // Other participants
        ]
}
</pre><p>To mark the Opus decoder context for the current participant as invalid and force it to be recreated, use the <code>resetdecoder</code> request:</p>
<pre class="fragment">{
        "request" : "resetdecoder"
}
</pre><p>A successful request will produce a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success"
}
</pre><p>You can add a new RTP forwarder for an existing room using the <code>rtp_forward</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "rtp_forward",
        "room" : &lt;unique numeric ID of the room to add the forwarder to&gt;,
        "ssrc" : &lt;SSRC to use to use when streaming (optional: stream_id used if missing)&gt;,
        "codec" : "&lt;opus (default), pcma (A-Law) or pcmu (mu-Law)&gt;",
        "ptype" : &lt;payload type to use when streaming (optional: 100 used if missing)&gt;,
        "host" : "&lt;host address to forward the RTP packets to&gt;",
        "host_family" : "&lt;ipv4|ipv6, if we need to resolve the host address to an IP; by default, whatever we get&gt;",
        "port" : &lt;port to forward the RTP packets to&gt;,
        "srtp_suite" : &lt;length of authentication tag (32 or 80); optional&gt;,
        "srtp_crypto" : "&lt;key to use as crypto (base64 encoded key as in SDES); optional&gt;",
        "always_on" : &lt;true|false, whether silence should be forwarded when the room is empty&gt;
}
</pre><p>Notice that, as explained above, in case you configured an <code>admin_key</code> property and extended it to RTP forwarding as well, you'll need to provide it in the request as well or it will be rejected as unauthorized. By default no limitation is posed on <code>rtp_forward</code> .</p>
<p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "stream_id" : &lt;unique numeric ID assigned to the new RTP forwarder&gt;,
        "host" : "&lt;host this forwarder is streaming to, same as request if not resolved&gt;",
        "port" : &lt;audio port this forwarder is streaming to, same as request&gt;
}
</pre><p>To stop a previously created RTP forwarder and stop it, you can use the <code>stop_rtp_forward</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "stop_rtp_forward",
        "room" : &lt;unique numeric ID of the room to remove the forwarder from&gt;,
        "stream_id" : &lt;unique numeric ID of the RTP forwarder&gt;
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "stream_id" : &lt;unique numeric ID, same as request&gt;
}
</pre><p>To get a list of the forwarders in a specific room, instead, you can make use of the <code>listforwarders</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "listforwarders",
        "room" : &lt;unique numeric ID of the room&gt;
}
</pre><p>A successful request will produce a list of RTP forwarders in a <code>forwarders</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "forwarders",
        "room" : &lt;unique numeric ID of the room&gt;,
        "rtp_forwarders" : [            // Array of RTP forwarder objects
                {       // RTP forwarder #1
                        "stream_id" : &lt;unique numeric ID of the forwarder&gt;,
                        "ip" : "&lt;IP this forwarder is streaming to&gt;",
                        "port" : &lt;port this forwarder is streaming to&gt;,
                        "ssrc" : &lt;SSRC this forwarder is using, if any&gt;,
                        "codec" : &lt;codec this forwarder is using, if any&gt;,
                        "ptype" : &lt;payload type this forwarder is using, if any&gt;,
                        "srtp" : &lt;true|false, whether the RTP stream is encrypted&gt;,
                        "always_on" : &lt;true|false, whether this forwarder works even when no participant is in or not&gt;
                },
                // Other forwarders
        ]
}
</pre><p>As anticipated, while the AudioBridge is mainly meant to allow real users to interact with each other by mixing their contributions, you can also start the playback of one or more pre-recorded audio files in a mix: this is especially useful whenever you have, for instance, to play an announcement of some sort, or when maybe you want to play some background music (e.g., some music on hold when the room is empty). You can start the playback of an .opus file in an existing room using the <code>play_file</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "play_file",
        "room" : &lt;unique numeric ID of the room to play the file in&gt;,
        "secret" : "&lt;room password, if configured&gt;",
        "file_id": "&lt;unique string ID of the announcement; random if not provided&gt;",
        "filename": "&lt;path to the Opus file to play&gt;",
        "loop": &lt;true|false, depending on whether or not the file should be played in a loop forever&gt;
}
</pre><p>Notice that, as explained above, in case you configured an <code>admin_key</code> property and extended it to RTP forwarding as well, you'll need to provide it in the request as well or it will be rejected as unauthorized. By default <code>play_file</code> only requires the room secret, meaning only people authorized to edit the room can start an audio playback.</p>
<p>Also notice that the only supported files are .opus files: no other audio format will be accepted. Besides, the file must be reachable and available on the file system: network addresses (e.g., HTTP URL) are NOT supported.</p>
<p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "file_id" : "&lt;unique string ID of the announcement, same as request if provided or randomly generated otherwise&gt;"
}
</pre><p>As soon as the playback actually starts (usually immediately after the request has been sent), an event is sent to all participants so that they're aware something is being played back in the room besides themselves:</p>
<pre class="fragment">{
        "audiobridge" : "announcement-started",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "file_id" : "&lt;unique string ID of the announcement&gt;"
}
</pre><p>A similar event is also sent whenever the playback stops, whether it's because the file ended and <code>loop</code> was <code>FALSE</code> (which will automatically clear the resources) or because a <code>stop_file</code> request asked for the playback to be interrupted:</p>
<pre class="fragment">{
        "audiobridge" : "announcement-stopped",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "file_id" : "&lt;unique string ID of the announcement&gt;"
}
</pre><p>You can check whether a specific playback is still going on in a room, you can use the <code>is_playing</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "is_playing",
        "room" : &lt;unique numeric ID of the room where the playback is taking place&gt;,
        "secret" : "&lt;room password, if configured&gt;",
        "file_id" : "&lt;unique string ID of the announcement&gt;"
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID&gt;,
        "file_id" : "&lt;unique string ID of the announcement&gt;",
        "playing" : &lt;true|false&gt;
}
</pre><p>As anticipated, when not looping a playback will automatically stop and self-destruct when it reaches the end of the audio file. In case you want to stop a playback sooner than that, or want to stop a looped playback, you can use the <code>stop_file</code> request:</p>
<pre class="fragment">{
        "request" : "stop_file",
        "room" : &lt;unique numeric ID of the room where the playback is taking place&gt;,
        "secret" : "&lt;room password, if configured&gt;",
        "file_id": "&lt;unique string ID of the announcement&gt;"
}
</pre><p>A successful request will result in a <code>success</code> response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
        "room" : &lt;unique numeric ID, same as request&gt;,
        "file_id" : "&lt;unique string ID of the now interrupted announcement&gt;"
}
</pre><p>That completes the list of synchronous requests you can send to the AudioBridge plugin. As anticipated, though, there are also several asynchronous requests you can send, specifically those related to joining and updating one's presence as a participant in an audio room.</p>
<p>The way you'd interact with the plugin is usually as follows:</p>
<ol type="1">
<li>you use a <code>join</code> request to join an audio room, and wait for the <code>joined</code> event; this event will also include a list of the other participants, if any;</li>
<li>you send a <code>configure</code> request attached to an audio-only JSEP offer to start configuring your participation in the room (e.g., join unmuted or muted), and wait for the related <code>event</code>, which will be attached to a JSEP answer by the plugin to complete the setup of the WebRTC PeerConnection;</li>
<li>you send other <code>configure</code> requests (without any JSEP-related attachment) to mute/unmute yourself during the audio conference;</li>
<li>you intercept events originated by the plugin (<code>joined</code> , <code>leaving</code> ) to notify you about users joining/leaving/muting/unmuting;</li>
<li>you eventually send a <code>leave</code> request to leave a room; if you leave the PeerConnection instance intact, you can subsequently join a different room without requiring a new negotiation (and so just use a <code>join</code> + JSEP-less <code>configure</code> to join).</li>
</ol>
<p>Notice that there's also a <code>changeroom</code> request available: you can use this request to immediately leave the room you're in and join a different one, without requiring you to do a <code>leave</code> + <code>join</code> + <code>configure</code> round. Of course remember not to pass any JSEP-related payload when doing a <code>changeroom</code> as the same pre-existing PeerConnection will be re-used for the purpose.</p>
<p>Notice that you can also ask the AudioBridge plugin to send you an offer, when you join, rather than providing one yourself: this means that the SDP offer/answer roles would be reversed, and so you'd have to provide an answer yourself in this case. Remember that, in case renegotiations or restarts take place, they MUST follow the same negotiation pattern as the one that originated the connection: it's an error to send an SDP offer to the plugin to update a PeerConnection, if the plugin sent you an offer originally. It's adviced to let users generate the offer, and let the plugin answer: this reverserd role is mostly here to facilitate the setup of cascaded mixers, e.g., allow one AudioBridge to connect to the other via WebRTC (which wouldn't be possible if both expected an offer from the other). Refer to the <a class="el" href="audiobridge.html#aboffer">AudioBridge-generated offers</a> section for more details.</p>
<p>About the syntax of all the above mentioned requests, <code>join</code> has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "join",
        "room" : &lt;numeric ID of the room to join&gt;,
        "id" : &lt;unique ID to assign to the participant; optional, assigned by the plugin if missing&gt;,
        "pin" : "&lt;password required to join the room, if any; optional&gt;",
        "display" : "&lt;display name to have in the room; optional&gt;",
        "token" : "&lt;invitation token, in case the room has an ACL; optional&gt;",
        "muted" : &lt;true|false, whether to start unmuted or muted&gt;,
        "codec" : "&lt;codec to use, among opus (default), pcma (A-Law) or pcmu (mu-Law)&gt;",
        "prebuffer" : &lt;number of packets to buffer before decoding this participant (default=room value, or DEFAULT_PREBUFFERING)&gt;,
        "quality" : &lt;0-10, Opus-related complexity to use, the higher the value, the better the quality (but more CPU); optional, default is 4&gt;,
        "volume" : &lt;percent value, &lt;100 reduces volume, &gt;100 increases volume; optional, default is 100 (no volume change)&gt;,
        "secret" : "&lt;room management password; optional, if provided the user is an admin and can't be globally muted with mute_room&gt;",
        "audio_level_average" : "&lt;if provided, overrides the room audio_level_average for this user; optional&gt;",
        "audio_active_packets" : "&lt;if provided, overrides the room audio_active_packets for this user; optional&gt;"
}
</pre><p>A successful request will produce a <code>joined</code> event:</p>
<pre class="fragment">{
        "audiobridge" : "joined",
        "room" : &lt;numeric ID of the room&gt;,
        "id" : &lt;unique ID assigned to the participant&gt;,
        "display" : "&lt;display name of the new participant&gt;",
        "participants" : [
                // Array of existing participants in the room
        ]
}
</pre><p>The other participants in the room will be notified about the new participant by means of a different <code>joined</code> event, which will only include the <code>room</code> and the new participant as the only object in a <code>participants</code> array.</p>
<p>At this point, the media-related settings of the participant can be modified by means of a <code>configure</code> request. The <code>configure</code> request has to be formatted as follows (notice that all parameters except <code>request</code> are optional, depending on what you want to change):</p>
<pre class="fragment">{
        "request" : "configure",
        "muted" : &lt;true|false, whether to unmute or mute&gt;,
        "display" : "&lt;new display name to have in the room&gt;",
        "prebuffer" : &lt;new number of packets to buffer before decoding this participant (see "join" for more info)&gt;,
        "quality" : &lt;new Opus-related complexity to use (see "join" for more info)&gt;,
        "volume" : &lt;new volume percent value (see "join" for more info)&gt;,
        "record": &lt;true|false, whether to record this user's contribution to a .mjr file (mixer not involved),
        "filename": "&lt;basename of the file to record to, -audio.mjr will be added by the plugin&gt;"
}
</pre><p><code>muted</code> instructs the plugin to mute or unmute the participant; <code>quality</code> changes the complexity of the Opus encoder for the participant; <code>record</code> can be used to record this participant's contribution to a Janus .mjr file, and <code>filename</code> to provide a basename for the path to save the file to (notice that this is different from the recording of a whole room: this feature only records the packets this user is sending, and is not related to the mixer stuff). A successful request will result in a <code>ok</code> event:</p>
<pre class="fragment">{
        "audiobridge" : "event",
        "room" : &lt;numeric ID of the room&gt;,
        "result" : "ok"
}
</pre><p>In case the <code>muted</code> property was modified, the other participants in the room will be notified about this by means of a <code>event</code> notification, which will only include the <code>room</code> and the updated participant as the only object in a <code>participants</code> array.</p>
<p>If you're the administrator of a room (that is, you created it and have access to the secret) you can mute or unmute individual participants using the <code>mute</code> or <code>unmute</code> request</p>
<pre class="fragment">{
        "request" : "&lt;mute|unmute, whether to mute or unmute&gt;",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;,
        "id" : &lt;unique numeric ID of the participant to mute|unmute&gt;
}
</pre><p>A successful request will result in a success response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
}
</pre><p>To mute/unmute the whole room, use <code>mute_room</code> and <code>unmute_room</code> instead.</p>
<pre class="fragment">{
        "request" : "&lt;mute_room|unmute_room, whether to mute or unmute&gt;",
        "secret" : "&lt;room secret, mandatory if configured&gt;",
        "room" : &lt;unique numeric ID of the room&gt;
}
</pre><p>A successful request will result in a success response:</p>
<pre class="fragment">{
        "audiobridge" : "success",
}
</pre><p>As anticipated, you can leave an audio room using the <code>leave</code> request, which has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "leave"
}
</pre><p>All the participants will receive an <code>event</code> notification with the ID of the participant who just left:</p>
<pre class="fragment">{
        "audiobridge" : "event",
        "room" : &lt;numeric ID of the room&gt;,
        "leaving" : &lt;numeric ID of the participant who left&gt;
}
</pre><p>For what concerns the <code>changeroom</code> request, instead, it's pretty much the same as a <code>join</code> request and as such has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "changeroom",
        "room" : &lt;numeric ID of the room to move to&gt;,
        "id" : &lt;unique ID to assign to the participant; optional, assigned by the plugin if missing&gt;,
        "display" : "&lt;display name to have in the room; optional&gt;",
        "token" : "&lt;invitation token, in case the new room has an ACL; optional&gt;",
        "muted" : &lt;true|false, whether to start unmuted or muted&gt;,
        "quality" : &lt;0-10, Opus-related complexity to use, lower is higher quality; optional, default is 4&gt;
}
</pre><p>Such a request will trigger all the above-described leaving/joined events to the other participants, as it is indeed wrapping a <code>leave</code> followed by a <code>join</code> and as such the other participants in both rooms need to be updated accordingly. The participant who switched room instead will be sent a <code>roomchanged</code> event which is pretty similar to what <code>joined</code> looks like:</p>
<p>A successful request will produce a <code>joined</code> event:</p>
<pre class="fragment">{
        "audiobridge" : "roomchanged",
        "room" : &lt;numeric ID of the new room&gt;,
        "id" : &lt;unique ID assigned to the participant in the new room&gt;,
        "display" : "&lt;display name of the new participant&gt;",
        "participants" : [
                // Array of existing participants in the new room
        ]
}
</pre><p>As a last note, notice that the AudioBridge plugin does support renegotiations, mostly for the purpose of facilitating ICE restarts: in fact, there isn't much need for renegotiations outside of that context, as PeerConnections here will typically always contain a single m-line for audio, and so adding/removing streams makes no sense; besides, muting and unmuting is available via APIs, meaning that updating the media direction via SDP renegotiations would be overkill.</p>
<p>To force a renegotiation, all you need to do is send the new JSEP offer together with a <code>configure</code> request: this request doesn't need to contain any directive at all, and can be empty. A JSEP answer will be sent back along the result of the request, if successful.</p>
<h2><a class="anchor" id="aboffer"></a>
AudioBridge-generated offers</h2>
<p>As anticipated in the previous sections, by default the AudioBridge plugin expects an SDP offer from users interested to join a room, and generates an SDP answer to complete the WebRTC negotiation process: this SDP offer can be provided either in a <code>join</code> request or a <code>configure</code> one, depending on how the app is constructed.</p>
<p>It's worth pointing out that the AudioBridge plugin also supports reversed roles when it comes to negotiation: that is, a user can ask the plugin to generate an SDP offer first, to which they'd provide an SDP answer to. This slightly changes the way the negotiation works within the context of the AudioBridge API, as some messages may have to be used in a different way. More specifically, if a user wants the plugin to generate an offer, they'll have to include a:</p>
<pre class="fragment">        [..]
        "generate_offer" : true,
        [..]
}
</pre><p>property in the <code>join</code> or <code>configure</code> request used to setup the PeerConnection. This means that the user will receive a JSEP SDP offer as part of the related event: at this point, the user needs to prepare to send a JSEP SDP answer and send it back to the plugin to complete the negotiation. The user must use the <code>configure</code> request to provide this SDP answer: no need to provide additional attributes in the request, unless it's needed for application related purposes (e.g., to start muted).</p>
<p>Notice that this does have an impact on renegotiations, e.g., for ICE restarts or changes in the media direction. As a policy, plugins in Janus tend to enforce the same negotiation pattern used to setup the PeerConnection initially for renegotiations too, as it reduces the risk of issues like glare: this means that users will NOT be able to send an SDP offer to the AudioBridge plugin to update an existing PeerConnection, if that PeerConnection had previously been originated by a plugin offer instead. The plugin will treat this as an error. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<div class="footer container">
<hr class="footer"/>
Last updated on Fri Apr 9 2021 &mdash; Janus WebRTC Server &copy; <a target="_blank" href="http://www.meetecho.com/">Meetecho</a> 2014-2021
</div>
</body>
</html>
