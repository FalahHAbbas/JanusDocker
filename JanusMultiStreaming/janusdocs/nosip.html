<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NoSIP plugin documentation</title>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cerulean/bootstrap.min.css" rel="stylesheet">
<link href="css/demo.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<a href="https://github.com/meetecho/janus-gateway"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 1001;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
<nav class="navbar navbar-default navbar-static-top">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href=".">Janus</a>
		<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
	</div>
	<div class="navbar-collapse collapse">
		<ul class="nav navbar-nav">
			<li><a href="https://janus.conf.meetecho.com/">Home</a></li>
			<li><a href="https://janus.conf.meetecho.com/demos.html">Demos</a></li>
			<li class="active"><a href="index.html">Documentation</a></li>
			<li><a href="https://janus.conf.meetecho.com/citeus.html">Papers</a></li>
			<li><a href="https://janus.conf.meetecho.com/support.html">Need help?</a></li>
			<li><a class="januscon" target="_blank" href="https://januscon.it">JanusCon!</a></li>
		</ul>
		<div class="navbar-header navbar-right">
			<ul class="nav navbar-nav">
				<li><a target="_blank" href="http://www.meetecho.com" class="navbar-link meetecho-logo"><img src="meetecho-logo.png"/></a></li>
			</ul>
		</div>
	</div>
</div>
</nav>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">NoSIP plugin documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is quite a basic plugin, as it only takes care of acting as an RTP bridge. It is named "NoSIP" since, as the name suggests, signalling takes no place here, and is entirely up to the application. The typical usage of this application is something like this:</p>
<ol type="1">
<li>a WebRTC application handles signalling on its own (e.g., SIP), but needs to interact with a peer that doesn't support WebRTC (DTLS/ICE);</li>
<li>it creates a handle with the NoSIP plugin, creates a JSEP SDP offer, and passes it to the plugin;</li>
<li>the plugin creates a barebone SDP that can be used to communicate with the legacy peer, binds to the ports for RTP/RTCP, and sends this plain SDP back to the application;</li>
<li>the application uses this barebone SDP in its signalling, and expects an answer from the peer;</li>
<li>the SDP answer from the peer will be barebone as well, and so unfit for WebRTC usage; as such, the application passes it to the plugin as the answer to match the offer created before;</li>
<li>the plugin matches the answer to the offer, and starts exchanging RTP/RTCP with the legacy peer: media coming from the peer is relayed via WebRTC to the application, and WebRTC stuff coming from the application is relayed via plain RTP/RTCP to the legacy peer.</li>
</ol>
<p>The same behaviour can be followed if the application is the callee instead, with the only difference being that the barebone offer will come from the peer in this case, and the application will ask the NoSIP plugin for a barebone answer instead.</p>
<p>As you can see, the behaviour is pretty much the same as the SIP plugin, with the key difference being that in this case there's no SIP stack in the plugin itself. All signalling is left to the application, and Janus (via the NoSIP plugin) is only responsible for bridging the media. This might be more appropriate than the SIP plugin in cases where developers want to keep control on the signalling layer, while still involving a server of sorts. Of course, SIP is just an example here: other signalling protocols may be involved as well (e.g., IAX, XMPP, others). The NoSIP plugin, though, will generate and expect plain SDP, so you'll need to take care of any adaptation that may be needed to make this work with the signalling protocol of your choice.</p>
<h1><a class="anchor" id="nosipapi"></a>
NoSIP Plugin API</h1>
<p>The plugin mainly supports two requests, <code>generate</code> and <code>process</code>, which are both asynchronous. The <code>generate</code> request take a JSEP offer or answer, and generates a barebone SDP the "legacy" application can use; the <code>process</code> request, on the other hand, processes a remote barebone SDP, and matches it to the plugin may have generated before, in order to then return a JSEP offer or answer that can be used to setup a PeerConnection.</p>
<p>The <code>generate</code> request must be formatted as follows:</p>
<pre class="fragment">{
        "request" : "generate",
        "info" : "&lt;opaque string that the user can provide for context; optional&gt;",
        "srtp" : "&lt;whether to mandate (sdes_mandatory) or offer (sdes_optional) SRTP support; optional&gt;",
        "srtp_profile" : "&lt;SRTP profile to negotiate, in case SRTP is offered; optional&gt;"
}
</pre><p>As anticipated, this requires a JSEP offer or answer passed via Janus API as part of a WebRTC PeerConnection negotiation. If the conversion of the WebRTC JSEP SDP to barebone SDP is successful, a <code>generated</code> event is sent back to the user:</p>
<pre class="fragment">{
        "event" : "generated",
        "type" : "&lt;offer|answer, depending on the nature of the provided JSEP&gt;",
        "sdp" : "&lt;barebone SDP content&gt;"
}
</pre><p>The <code>process</code> request, instead, must be formatted as follows:</p>
<pre class="fragment">{
        "request" : "process",
        "type" : "&lt;offer|answer, depending on the nature of the provided SDP&gt;",
        "sdp" : "&lt;barebone SDP to convert&gt;"
        "info" : "&lt;opaque string that the user can provide for context; optional&gt;",
        "srtp" : "&lt;whether to mandate (sdes_mandatory) or offer (sdes_optional) SRTP support; optional&gt;",
        "srtp_profile" : "&lt;SRTP profile to negotiate, in case SRTP is offered; optional&gt;"
}
</pre><p>As anticipated, this requires a "legacy" SDP offer or answer passed via NoSIP plugin messaging, which is why the caller must specify if it's an offer or answer. If the request is successful, a <code>processed</code> event is sent back to the user, along to the JSEP offer or answer that Janus generated out of the barebone SDP:</p>
<pre class="fragment">{
        "event" : "processed",
        "srtp" : "&lt;whether the barebone SDP mandates (sdes_mandatory) or offers (sdes_optional) SRTP support; optional&gt;"
}
</pre><p>To close a session you can use the <code>hangup</code> request, which needs no additional arguments, as the whole context can be extracted from the current state of the session in the plugin:</p>
<pre class="fragment">{
        "request" : "hangup"
}
</pre><p>An <code>hangingup</code> event will be sent back, as this is an asynchronous request.</p>
<p>Finally, just as in the SIP and SIPre plugins, the multimedia session can be recorded. Considering the NoSIP plugin also assumes two peers are in a call with each other (although it makes no assumptions on the signalling that ties them together), it works exactly the same way as the SIP and SIPre plugin do when it comes to recording. Specifically, you make use of the <code>recording</code> request to either start or stop a recording, using the following syntax:</p>
<pre class="fragment">{
        "request" : "recording",
        "action" : "&lt;start|stop, depending on whether you want to start or stop recording something&gt;"
        "audio" : &lt;true|false; whether or not our audio should be recorded&gt;,
        "video" : &lt;true|false; whether or not our video should be recorded&gt;,
        "peer_audio" : &lt;true|false; whether or not our peer's audio should be recorded&gt;,
        "peer_video" : &lt;true|false; whether or not our peer's video should be recorded&gt;,
        "filename" : "&lt;base path/filename to use for all the recordings&gt;"
}
</pre><p>As you can see, this means that the two sides of conversation are recorded separately, and so are the audio and video streams if available. You can choose which ones to record, in case you're interested in just a subset. The <code>filename</code> part is just a prefix, and dictates the actual filenames that will be used for the up-to-four recordings that may need to be enabled.</p>
<p>A <code>recordingupdated</code> event is sent back in case the request is successful. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<div class="footer container">
<hr class="footer"/>
Last updated on Fri Apr 9 2021 &mdash; Janus WebRTC Server &copy; <a target="_blank" href="http://www.meetecho.com/">Meetecho</a> 2014-2021
</div>
</body>
</html>
